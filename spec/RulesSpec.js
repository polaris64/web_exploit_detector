/* eslint-env jasmine */

const Promise = require('bluebird');
const fs      = Promise.promisifyAll(require('graceful-fs'));

const rules              = require('../lib/web_exploit_detector').rules;
const processRulesOnFile = require('../lib/web_exploit_detector').processRulesOnFile;

function setUpFileReadSpy(files) {
  spyOn(fs, 'readFileAsync')
    .and.callFake(function(file) {
      return files[file] ? Promise.resolve(files[file].content) : Promise.reject(new Error('File not found'));
    });
}

function assertRuleForFiles(files, rules) {
  return Promise.mapSeries(
    Object.keys(files).map(file => () =>
      processRulesOnFile(file, rules)
        .then(res => {
          expect(res.file).toBeDefined('Result of processing rules does not contain file name');
          expect(res.file).toBe(file, 'File name in result of processing rules should be ' + file);
          expect(res.matches).toBeDefined('Result of processing rules does not contain a "matches" array');
          expect(res.matches.length).toBe(files[file].match ? 1 : 0, 'Number of matches for this file should be ' + (files[file].match ? '1' : '0'));
          if (files[file].match)
          {
            expect(res.matches[0]).toBeDefined('As file matches rule, first match should be the current rule');
            if (res.matches[0])
              expect(res.matches[0].id).toBe(rules[0].id, 'ID of matched rule does not match rule being tested');
            expect(fs.readFileAsync).toHaveBeenCalledWith(file);
          }

          return res;
        })
    ),
    thunk => thunk()
  );
}

describe('Rule list', function() {
  it('should contain > 0 rules', function() {
    expect(rules).toBeDefined();
    expect(rules.length).toBeGreaterThan(0);
  });

  it('should be an array of rules, each with a valid format', function() {
    expect(rules).toHaveAllValidRules();
  });

  it('should contain a list of rules, each with an unique ID', function() {
    expect(rules).toHaveUniqueRuleIDs();
  });

});


describe('Rule', function() {

  describe('P64:general:obfuscation:scripts_with_escaped_ascii', function() {
    it('should match the correct set of files', function(done) {
      const ruleName = 'P64:general:obfuscation:scripts_with_escaped_ascii';
      const activeRules = rules.filter(x => x.id === ruleName);
      const files = {
        'unmatched.dat': {match: false, content: '\\x21\\x22\\x23\\x24'},
        'matched.php': {match: true, content: '\\x21\\x22\\x23\\x24'},
        'matched.js': {match: true, content: '\\x21\\x22\\x23\\x24'},
        'matched.aspx': {match: true, content: '\\x21\\x22\\x23\\x24'},
        'matched.asp': {match: true, content: '\\x21\\x22\\x23\\x24'},
        'unmatched_content.php': {match: false, content: '\\x21\\xff\\x22\\x23\\x24'},
        'classes/Swift/Mime/Headers/ParameterizedHeader.php': {match: false, content: '\\x21\\x22\\x23\\x24'},
        'Swift/Encoder/Rfc2231EncoderTest.php': {match: false, content: '\\x21\\x22\\x23\\x24'}
      };
      setUpFileReadSpy(files);
      assertRuleForFiles(files, activeRules).then(done);
    });
  });

  describe('P64:js:jquery:obfuscated_document_write', function() {
    it('should match the correct set of files', function(done) {
      const ruleName = 'P64:js:jquery:obfuscated_document_write';
      const activeRules = rules.filter(x => x.id === ruleName);
      const files = {
        'match/jquery.js':         {match: true, content: '\\x77\\x72\\x69\\x74\\x65'},
        'match/jquery.min.js':     {match: true, content: '\\x77\\x72\\x69\\x74\\x65'},
        'unmatched/jquery.js':     {match: false, content: 'document'},
        'unmatched/jquery.min.js': {match: false, content: 'document'},
      };
      setUpFileReadSpy(files);
      assertRuleForFiles(files, activeRules).then(done);
    });
  });

});
