/* eslint-env jasmine */

beforeEach(function() {

  /**
   * Checks if a single rule is valid
   *
   * @param actual Rule object
   * @return object Object containing "pass" (Boolean) and "message" (string)
   */
  const _isValidRule = function(actual) {
    var messages = [];
    if (actual.id === undefined || actual.id.toString().trim().length === 0)
      messages.push(`Rule does not contain a valid "id" field`);
    if (actual.name === undefined && actual.name.toString().trim().length === 0)
      messages.push(`Rule ${actual.id} does not contain a valid "name" field`);
    if (actual.description === undefined)
      messages.push(`Rule ${actual.id} does not contain a "description" field`);
    if (actual.urls === undefined)
      messages.push(`Rule ${actual.id} does not contain a "urls" field`);
    if (!(actual.urls === null || actual.urls instanceof Array))
      messages.push(`Rule ${actual.id} "urls" field must either be null or an array of strings`);
    if (typeof actual.deprecated !== 'boolean')
      messages.push(`Rule ${actual.id} must contain a "deprecated" Boolean field`);

    if (typeof actual.tests !== 'object')
      messages.push(`Rule ${actual.id} must contain a "tests" object containing tests`);
    else
    {
      if (!actual.tests.path || !(typeof actual.tests.path === 'function' || actual.tests.path instanceof RegExp))
        messages.push(`Rule ${actual.id} "tests.path" field must either be a function or a regular expression`);
      if (actual.tests.content && !(typeof actual.tests.content === 'function' || actual.tests.content instanceof RegExp))
        messages.push(`Rule ${actual.id} "tests.content" field must either be a function, a regular expression or null`);
    }

    return {
      pass: messages.length === 0,
      message: messages.length === 0 ?
        'Rule does not have the correct format' : messages.join(', '),
    };
  };

  jasmine.addMatchers({

    toBeValidRule: function() {
      return {
        compare: function(actual) {
          return _isValidRule(actual);
        },
      };
    },

    toHaveAllValidRules: function() {
      return {
        compare: function(actual) {

          // Make sure actual is an Array
          if (!actual || !(actual instanceof Array))
            return {
              pass: false,
              message: 'List of rules must be an array',
            };

          // Get messages for all failed rules
          const messages = actual
            .map(x => _isValidRule(x))
            .filter(x => !x.pass)
            .map(x => x.message);

          // Return matcher response
          return {
            pass: messages.length === 0,
            message: messages.length === 0 ? 'Array of rules contains an invalid rule' : messages.join(', '),
          };
        },
      };
    },

    toHaveUniqueRuleIDs: function() {
      return {
        compare: function(actual) {

          // Make sure actual is an Array
          if (!actual || !(actual instanceof Array))
            return {
              pass: false,
              message: 'List of rules must be an array',
            };

          // Get list of found IDs and IDs which are duplicated
          const ids = actual
            .map(x => x.id)
            .reduce((a, id) => {
              if (a.all.filter(x => x.toString().toLowerCase() === id.toString().toLowerCase()).length > 0)
                a.dup.push(id);
              else
                a.all.push(id);
              return a;
            }, {all: [], dup: []});

          // Return matcher response
          return {
            pass: ids.dup.length === 0,
            message: ids.dup.length === 0 ?
              'Rules do not have unique IDs' :
              `The following rule IDs are not unique: ${ids.dup.join(', ')}`,
          };
        },
      };
    },
  });
});
