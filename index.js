/*
ISC License

Copyright (c) 2017, Simon Pugnet

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
*/

const Promise = require('bluebird');

const argv = require('minimist')(process.argv.slice(2));
const fs   = Promise.promisifyAll(require('graceful-fs'));
const path = require('path');

const rules = require('./rules');

if (!argv.webroot)
{
  console.error('--webroot command line argument must be specified\n');
  printUsage();
  process.exit(1);
}

function printUsage() {
  console.log(`Usage: ${process.argv[1]} --webroot=<web_root>`);
  console.log('  --debug: sets the debug flag. Outputs more verbosely and enables the "debug" rules.');
  console.log('  --exclude-tags=<list>: excludes all rules that include one or more of the comma-separated tags in <list>.');
  console.log('  --include-deprecated: includes rulesmarked as deprecated.');
  console.log('  --tags=<list>: only runs rules matching the comma-separated <list> of tags.');
  console.log('  --webroot=<web_root>: sets the base directory that will be searched recursively to <web_root>.');
  console.log('\n\nExamples: ');
  console.log('  - Search the /var/www/html directory structure: -');
  console.log(`    node ${process.argv[1]} --webroot=/var/www/html`);
  console.log('  - Search using only WordPress-related rules: -');
  console.log(`    node ${process.argv[1]} --webroot=/var/www/html --tags=wordpress`);
  console.log('  - Search using all rules except those tagged with "jquery" or "js": -');
  console.log(`    node ${process.argv[1]} --webroot=/var/www/html --exclude-tags=jquery,js`);
}

function executeTests(settings) {
  console.log('Getting file list...');

  return getFileList(settings.webroot)
    .then(files => {
      const activeRules = rules

        // Remove debug rules if not in debug mode
        .filter(rule => settings.debug ? true : rule.tags.filter(tag => tag === 'debug').length === 0)

        // Remove deprecated rules unless "include_deprecated" is set
        .filter(rule => settings.include_deprecated ? true : !rule.deprecated)

        // Remove all rules not in "tags" (if set)
        .filter(rule => {
          if (!settings.tags)
            return true;
          const tags_arr = settings.tags.split(',').map(x => x.trim().toLowerCase());
          return rule.tags.filter(tag => tags_arr.filter(x => x === tag).length > 0).length > 0;
        })

        // Remove all rules with tags included in "exclude_tags" (if set)
        .filter(rule => {
          if (!settings.exclude_tags)
            return true;
          const tags_arr = settings.exclude_tags.split(',').map(x => x.trim().toLowerCase());
          return rule.tags.filter(tag => tags_arr.filter(x => x === tag).length > 0).length === 0;
        });

      console.log(`Processing ${activeRules.length} rules on ${files.length} files...`);

      // Process each rule (each rule returns a Promise)
      const promises = activeRules.length === 0 ?
        [] :
        activeRules
          .map(rule => processRule(rule, files, settings));

      Promise.all(promises)
        .then(res =>
          console.log(
            'Processing complete, results: -\n\n' +
            res
              .map(x =>
                x.matches.length > 0 ?
                  `${x.rule.deprecated ? 'DEPRECATED RULE:' : 'Rule:'} ${x.rule.name} (${x.matches.length} matches): -\n` +
                    (x.rule.urls && x.rule.urls.length > 0 ? `References: ${x.rule.urls.join(', ')}\n` : '') +
                    x.matches.map(m => ' - ' + m).join('\n') + '\n'
                  : null
              )
              .filter(x => x !== null)
              .join('\n')
          )
        );
    });
}

function getFileList(path) {
  return readDirRecursive(path)
    .catch(err => {
      console.error(`Error reading webroot directory: ${err.toString()}`);
      return [];
    });
}

function readDirRecursive(basePath) {
  var list = [];
  return fs.readdirAsync(basePath)
    .then(res => {
      return Promise.all(res.map(x => {
        const filePath = path.join(basePath, x);
        return fs.statAsync(filePath).then(stat => ({file: filePath, stat}));
      }));
    })
    .then(res => {
      res.filter(x => !x.stat.isDirectory()).forEach(x => list.push(x.file));
      return Promise.all(res.filter(x => x.stat.isDirectory()).map(x => readDirRecursive(x.file, list)))
        .then(lists => lists.forEach(x => x.forEach(y => list.push(y))));
    })
    .then(() => {
      return list;
    })
    .catch(err => {
      console.error(`ERROR: unable to process ${basePath}: ${err.toString()}`);
      return list;
    });
}

function processRule(rule, files) {
  if (!rule.test)
    return Promise.resolve({rule, matches: []});

  if (typeof rule.test === 'function')
  {
    const pending = files.map(f => {
      const testResult = rule.test(f.toString());
      return {file: f, matched: testResult, pending: !!testResult.then};
    });

    const promises = pending.filter(x => x.pending);
    if (promises.length > 0)
    {
      return Promise.all(pending.map(x => x.matched.then(res => ({file: x.file, matched: res, pending: false}))))
        .then(res => {
          return {
            rule,
            matches: res.filter(x => x.matched).map(x => x.file),
          };
        });
    }
    else
    {
      return Promise.resolve({
        rule,
        matches: pending.filter(x => x.matched).map(x => x.file),
      });
    }
  }

  return Promise.resolve({
    rule,
    matches: files.filter(f => f.toString().match(rule.test)),
  });
}

executeTests({
  debug:              argv.debug,
  exclude_tags:       argv['exclude-tags'],
  include_deprecated: argv['include-deprecated'],
  tags:               argv.tags,
  webroot:            argv.webroot,
});
