/* eslint no-console: ["error", {"allow": ["log", "warn", "error"]}] */

import {loadExceptions} from './web_exploit_detector';

import minimist from 'minimist';
import path     from 'path';
import Promise  from 'bluebird';
import prompt   from './prompt';

const fs = Promise.promisifyAll(require('graceful-fs'));

const argv = minimist(
  process.argv.slice(2),
  {
    boolean: true,
    default: {'results': undefined},
  }
);


function printUsage() {
  console.log('This script processes an existing JSON results file produced by the Web Exploit Detector and generates a list of exceptions (in exceptions.json) based on user input.\n');
  console.log(`Usage: node ${process.argv[1]} --results=<results_json>`);
  console.log('  --results=<results_json>: path to a JSON results file produced by the Web Exploit Detector.');
}

function loadResults(file) {
  return fs.readFileAsync(file)
    .then(JSON.parse);
}

function saveExceptions(exceptions) {
  return fs.writeFileAsync(path.join(__dirname, 'exceptions.json'), JSON.stringify(exceptions, null, '\t'))
    .then(() => console.log('exceptions.json written successfully'))
    .catch(err => console.error(`ERROR: unable to write results to exceptions.json: ${err.toString()}`));
}

function processResults(exceptions, results) {
  const thunks = results.map(res => {

    // Thunk to initiate choice gatering for rule
    return () => {
      console.log(`RULE: ${res.rule.name}`);
      return res.matches.map(match => {

        // Thunk to initiate choice gatering for file
        return (skipRule) => {
          return skipRule ? Promise.resolve({
            rule_id: res.rule.id,
            file: match,
            exclude: false,
            skip: true,
          }) :
            prompt.prompt('  ' + match + '\n  Exclude this file from the rule? [y/N/s]')
              .then(response => {
                return {
                  rule_id: res.rule.id,
                  file: match,
                  exclude: response
                    .toUpperCase()
                    .slice(0, 1) === 'Y',
                  skip: response
                    .toUpperCase()
                    .slice(0, 1) === 'S',
                };
              });
        };
        
      });
    };

  });

  return Promise.mapSeries(thunks, ruleThunk => {
    var skipRule = false;
    return Promise.mapSeries(ruleThunk(), fileThunk => {
      return fileThunk(skipRule)
        .then(res => {
          if (res.skip)
            skipRule = true;
          return res;
        });
    })
      .then(res => {
        const temp = {
          rule_id: res.length > 0 ? res[0].rule_id : null,
          files: res
            .filter(x => x.exclude)
            .map(x => x.file),
        };
        return temp;
      });
  })
    .then(res => {
      return res
      
        // Remove rules for which no files were excluded
        .filter(x => x.files.length > 0)

        .reduce((acc, rule) => {
          rule.files.forEach(f => {
            if (acc[f])
              acc[f].push(rule.rule_id);
            else
              acc[f] = [rule.rule_id];
          });
          return acc;
        }, {});
    });
}

export default function execute() {
  console.log('Script to generate exceptions from Web Exploit Detector results ((c) Simon Pugnet 2017)\n');

  if (!argv.results || typeof argv.results === 'boolean')
  {
    printUsage();
    process.exit(1);
  }

  loadExceptions()
    .then(exceptions => {
      return loadResults(argv.results)
        .then(results => {
          
          console.log('You will now be asked whether you want to exclude each matched file for each rule.\n\nFor each file, you can answer either "y" to exclude the file for the rule, "n" (default) to keep the file as a candidate for the rule, or "s" to skip the remaining files for the rule. When skipping, all remaining files to check will not be excluded.\nTo end the script prematurely without writing any new exceptions, enter Ctrl-C.\n');

          // Start prompting user
          prompt.start();

          return processResults(exceptions, results)
            .then(newExceptions => {
              var final = newExceptions;

              // All prompting now complete
              prompt.end();

              // Merge existing exceptions
              Object.keys(exceptions).forEach(k => {
                if (final[k])
                  final[k] = final[k].concat(exceptions[k]);
                else
                  final[k] = exceptions[k];
              });

              return final;
            })

            // Write final exceptions back to file
            .then(saveExceptions)

            .then(() => console.log('Script completed'));
        })

        .catch(err => {
          prompt.end();
          console.error(`ERROR: ${err.toString()}`);
        });
    });
}
