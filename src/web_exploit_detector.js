const Promise = require('bluebird');

const fs   = Promise.promisifyAll(require('graceful-fs'));
const path = require('path');

const rules = require('../rules');

function executeTests(settings) {
  if (!settings.logger)
    settings.logger = (level, msg) => msg;

  settings.logger(3, 'Getting file list...');

  return getFileList(settings.webroot, settings.logger)
    .then(files => {

      // Complete processing of all rules
      //  - Parallel mode: return the result of Promise.all()
      //  - Serial mode: use mapSeries() to call each function in the array in
      //    turn in order to process the rule
      const _processPromises = (promises) =>
        settings.parallel ?
          Promise.all(promises) :
          Promise.mapSeries(
            promises,
            func => func()
          );

      const activeRules = rules

        // Remove debug rules if not in debug mode
        .filter(rule => settings.debug ? true : rule.tags.filter(tag => tag === 'debug').length === 0)

        // Remove deprecated rules unless "include_deprecated" is set
        .filter(rule => settings.include_deprecated ? true : !rule.deprecated)

        // Remove all rules not in "tags" (if set)
        .filter(rule => {
          if (!settings.tags)
            return true;
          const tags_arr = settings.tags.split(',').map(x => x.trim().toLowerCase());
          return rule.tags.filter(tag => tags_arr.filter(x => x === tag).length > 0).length > 0;
        })

        // Remove all rules with tags included in "exclude_tags" (if set)
        .filter(rule => {
          if (!settings.exclude_tags)
            return true;
          const tags_arr = settings.exclude_tags.split(',').map(x => x.trim().toLowerCase());
          return rule.tags.filter(tag => tags_arr.filter(x => x === tag).length > 0).length === 0;
        });

      settings.logger(3, `Processing ${activeRules.length} rules ${settings.parallel ? 'in parallel ' : ''}on ${files.length} files...`);

      // Process depending on current settings.mode
      //  - Parallel mode: map each rule to the result of processing the rule
      //    (a Promise) directly
      //  - Serial mode: map each rule to a function that can be called to
      //    start rule processing
      switch (settings.mode.trim().toLowerCase())
      {
        // For each file, process all rules
        case 'files':
          return _processPromises(
            files.length === 0 ?
              [] :
              (settings.parallel ?
                files.map(file => processRulesOnFile(file, activeRules, settings)) :
                files.map(file => () => processRulesOnFile(file, activeRules, settings))
              )
          )
            // Re-group "file => matched rules" to "rule => matched files" and
            // remove rules with no matches
            .then(res => {
              const ruleMatches = res
                .reduce((acc, filerec) => {
                  if (filerec.matches.length === 0)
                    return acc;
                  filerec.matches.forEach(ruleMatch => {
                    if (acc[ruleMatch.id])
                      acc[ruleMatch.id].matches.push(filerec.file);
                    else
                      acc[ruleMatch.id] = {rule: ruleMatch, matches: [filerec.file]};
                  });
                  return acc;
                }, {});
              return Object.keys(ruleMatches).map(ruleID => ruleMatches[ruleID]);
            });

        // For each rule, process all files
        case 'rules':
          return _processPromises(
            activeRules.length === 0 ?
              [] :
              (settings.parallel ?
                activeRules.map(rule => processRuleOnFiles(rule, files, settings)) :
                activeRules.map(rule => () => processRuleOnFiles(rule, files, settings))
              )
          )
            // Remove rules with no matches
            .then(res => res.filter(x => x.matches.length > 0));

        default:
          return Promise.reject(new Error(`ERROR: unknown operating mode "${settings.mode.trim().toLowerCase()}"`))
      }
    });
}

function getFileList(path, logger = null) {
  return readDirRecursive(path, logger)
    .catch(err => {
      if (logger)
        logger(2, `WARN: Error reading webroot directory: ${err.toString()}`);
      return [];
    });
}

function readDirRecursive(basePath, logger = null) {
  var list = [];
  return fs.readdirAsync(basePath)
    .then(res => {
      return Promise.all(res.map(x => {
        const filePath = path.join(basePath, x);
        return fs.statAsync(filePath).then(stat => ({file: filePath, stat}));
      }));
    })
    .then(res => {
      res.filter(x => !x.stat.isDirectory()).forEach(x => list.push(x.file));
      return Promise.all(res.filter(x => x.stat.isDirectory()).map(x => readDirRecursive(x.file, logger)))
        .then(lists => lists.forEach(x => x.forEach(y => list.push(y))));
    })
    .then(() => {
      return list;
    })
    .catch(err => {
      if (logger)
        logger(1, `ERROR: unable to process ${basePath}: ${err.toString()}`);
      return list;
    });
}

function processSingleRule(file, rule) {
  if (!rule.test)
    return Promise.resolve(false);

  if (typeof rule.test === 'function')
  {
    const testResult = rule.test(file.toString());
    if (testResult.then)
      return testResult;
    else
      return Promise.resolve(testResult);
  }

  return Promise.resolve(!!file.toString().match(rule.test));
}

function processRulesOnFile(file, rules) {
  return Promise.all(
    rules.map(r => processSingleRule(file, r).then(res => ({rule: r, matched: res})))
  )
    .then(res => ({
      file,
      matches: res.filter(x => x.matched).map(x => x.rule),
    }));
}

function processRuleOnFiles(rule, files, settings) {
  if (settings.logger)
    settings.logger(4, `Processing rule ${rule.id}...`);

  if (!rule.test)
    return Promise.resolve({rule, matches: []});

  return Promise.all(
    files.map(f => processSingleRule(f, rule).then(res => ({file: f, matched: res})))
  )
    .then(res => {
      if (settings.logger && settings.parallel)
        settings.logger(4, `Finished processing rule ${rule.id}`);
      return {
        rule,
        matches: res.filter(x => x.matched).map(x => x.file),
      };
    });
}

function formatResult(res) {
  return res.matches.length > 0 ?
    `${res.rule.deprecated ? 'DEPRECATED RULE:' : 'Rule:'} ${res.rule.name} (${res.matches.length} matches)\n` +
      (res.rule.urls && res.rule.urls.length > 0 ? `References: ${res.rule.urls.join(', ')}\n` : '') +
      res.matches.map(m => ' - ' + m).join('\n') + '\n'
    : null;
}

module.exports = {
  rules,

  executeTests,
  formatResult,
  getFileList,
  processRuleOnFiles,
  processRulesOnFile,
  processSingleRule,
  readDirRecursive,
};
