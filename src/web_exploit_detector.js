const Promise = require('bluebird');

const fs   = Promise.promisifyAll(require('graceful-fs'));
const path = require('path');

const rules = require('../rules');

function executeTests(settings) {
  if (!settings.logger)
    settings.logger = (level, msg) => msg;

  settings.logger(3, 'Getting file list...');

  return getFileList(settings.webroot, settings.logger)
    .then(files => {
      const activeRules = rules

        // Remove debug rules if not in debug mode
        .filter(rule => settings.debug ? true : rule.tags.filter(tag => tag === 'debug').length === 0)

        // Remove deprecated rules unless "include_deprecated" is set
        .filter(rule => settings.include_deprecated ? true : !rule.deprecated)

        // Remove all rules not in "tags" (if set)
        .filter(rule => {
          if (!settings.tags)
            return true;
          const tags_arr = settings.tags.split(',').map(x => x.trim().toLowerCase());
          return rule.tags.filter(tag => tags_arr.filter(x => x === tag).length > 0).length > 0;
        })

        // Remove all rules with tags included in "exclude_tags" (if set)
        .filter(rule => {
          if (!settings.exclude_tags)
            return true;
          const tags_arr = settings.exclude_tags.split(',').map(x => x.trim().toLowerCase());
          return rule.tags.filter(tag => tags_arr.filter(x => x === tag).length > 0).length === 0;
        });

      settings.logger(3, `Processing ${activeRules.length} rules ${settings.parallel ? 'in parallel ' : ''}on ${files.length} files...`);

      // Process each rule (each rule returns a Promise)
      //  - Parallel mode: map each rule to the result of calling processRule()
      //    directly
      //  - Serial mode: map each rule to a function that can be called to
      //    start rule processing
      const promises = activeRules.length === 0 ?
        [] :
        (settings.parallel ?
          activeRules.map(rule => processRule(rule, files, settings)) :
          activeRules.map(rule => () => processRule(rule, files, settings))
        )

      // Complete processing of all rules
      //  - Parallel mode: return the result of Promise.all()
      //  - Serial mode: use mapSerial() to call each function in the array in
      //    turn in order to process the rule
      return settings.parallel ?
        Promise.all(promises) :
        Promise.mapSeries(
          promises,
          func => func()
        )
    });
}

function getFileList(path, logger = null) {
  return readDirRecursive(path, logger)
    .catch(err => {
      if (logger)
        logger(2, `WARN: Error reading webroot directory: ${err.toString()}`);
      return [];
    });
}

function readDirRecursive(basePath, logger = null) {
  var list = [];
  return fs.readdirAsync(basePath)
    .then(res => {
      return Promise.all(res.map(x => {
        const filePath = path.join(basePath, x);
        return fs.statAsync(filePath).then(stat => ({file: filePath, stat}));
      }));
    })
    .then(res => {
      res.filter(x => !x.stat.isDirectory()).forEach(x => list.push(x.file));
      return Promise.all(res.filter(x => x.stat.isDirectory()).map(x => readDirRecursive(x.file, logger)))
        .then(lists => lists.forEach(x => x.forEach(y => list.push(y))));
    })
    .then(() => {
      return list;
    })
    .catch(err => {
      if (logger)
        logger(1, `ERROR: unable to process ${basePath}: ${err.toString()}`);
      return list;
    });
}

function processRule(rule, files, settings) {
  if (!rule.test)
    return Promise.resolve({rule, matches: []});

  if (settings.logger)
    settings.logger(4, `Processing rule ${rule.id}...`);

  const _finished = () => {
    if (settings.logger && settings.parallel)
      settings.logger(4, `Finished processing rule ${rule.id}`);
  };

  if (typeof rule.test === 'function')
  {
    const pending = files.map(f => {
      const testResult = rule.test(f.toString());
      return {file: f, matched: testResult, pending: !!testResult.then};
    });

    const promises = pending.filter(x => x.pending);
    if (promises.length > 0)
    {
      return Promise.all(pending.map(x => x.matched.then(res => ({file: x.file, matched: res, pending: false}))))
        .then(res => {
          _finished();
          return {
            rule,
            matches: res.filter(x => x.matched).map(x => x.file),
          };
        });
    }
    else
    {
      _finished();
      return Promise.resolve({
        rule,
        matches: pending.filter(x => x.matched).map(x => x.file),
      });
    }
  }

  _finished();
  return Promise.resolve({
    rule,
    matches: files.filter(f => f.toString().match(rule.test)),
  });
}

function formatResult(res) {
  return res.matches.length > 0 ?
    `${res.rule.deprecated ? 'DEPRECATED RULE:' : 'Rule:'} ${res.rule.name} (${res.matches.length} matches)\n` +
      (res.rule.urls && res.rule.urls.length > 0 ? `References: ${res.rule.urls.join(', ')}\n` : '') +
      res.matches.map(m => ' - ' + m).join('\n') + '\n'
    : null;
}

module.exports = {
  rules,

  executeTests,
  formatResult,
  getFileList,
  processRule,
  readDirRecursive,
};
