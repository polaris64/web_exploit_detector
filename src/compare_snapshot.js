import {getTreeSnapshot} from './web_exploit_detector';
import Logger from './logger';

import minimist from 'minimist';
import Promise  from 'bluebird';

const fs = Promise.promisifyAll(require('graceful-fs'));

const argv = minimist(
  process.argv.slice(2),
  {
    boolean: true,
    default: {
      'help':     false,
      'snapshot': undefined,
      'verbose':  false,
      'webroot':  undefined,
    },
  }
);

const logger = new Logger(argv);

function printUsage() {
  logger.log(3, `Usage: node ${process.argv[1]} --snapshot=<snapshot_file>`);
  logger.log(3, '  --help: shows this message');
  logger.log(3, '  --snapshot=<snapshot_file>: a previously generated snapshot file.');
  logger.log(3, '  --verbose: enables verbose log output.');
  logger.log(3, '  --webroot=<web_root>: sets the base directory that will be scanned recursively to <web_root>. This is stored in the snapshot itself, so this option should only be set if the value in the snapshot needs to be overridden.');
}

export default function execute() {
  logger.log(3, 'Directory tree snapshot checking utility ((c) Simon Pugnet 2017)\n');
  logger.log(4, 'This tool compares all files and their contents in a directory with a previously generated snapshot of that same directory, specified by --snapshot. Any differences between the two will be displayed.');

  if (argv.help)
  {
    printUsage();
    process.exit(0);
  }

  if (!(argv.snapshot && typeof argv.snapshot !== 'boolean' && argv.snapshot.toString().length > 0))
  {
    logger.log(1, 'ERROR: --snapshot command line argument must be specified\n');
    printUsage();
    process.exit(1);
  }

  // Read the existing snapshot
  return fs.readFileAsync(argv.snapshot)

    // Parse and validate the existing snapshot
    .then(existingSnap => {
      let existing = JSON.parse(existingSnap.toString());

      // Make sure snapshot contains data
      if (!existing.data)
        existing = {
          meta: {},
          data: existing,
        };

      // Make sure snapshot contains a meta.webroot attribute. If it does not
      // then set it based on --webroot (if possible)
      if (!(existing.meta && existing.meta.webroot))
      {
        if (!argv.webroot)
          return Promise.reject(new Error('This snapshot does not contain a webroot so the --webroot command line argument must be specified when using this snapshot file'));

        if (!existing.meta)
          existing.meta = {};
        existing.meta.webroot = argv.webroot;

        // If the existing snapshot did not include a webroot then all paths
        // will be absolute so set a flag to prevent the snapshot generator
        // from generating relative paths
        existing.meta.absolute = true;
      }

      // If --webroot was specified, override value stored in snapshot
      else if (argv.webroot && typeof argv.webroot !== 'boolean' && argv.webroot.toString().length > 0)
      {
        logger.log(2, `WARNING: snapshot contains a webroot value of ${existing.meta.webroot} however the --webroot option was specified, so overriding this value to ${argv.webroot}...`);
        existing.meta.webroot = argv.webroot;
      }

      if (existing.meta.timestamp)
        logger.log(3, `Comparing snapshot generated for path ${existing.meta.webroot} at ${(new Date(existing.meta.timestamp)).toString()}`);

      return existing;
    })

    // Generate a new snapshot
    .then(existing =>
      getTreeSnapshot({
        output:  argv.output,
        verbose: argv.verbose,
        webroot: existing.meta.webroot,

        logger:   logger.log,
        relative: !existing.meta.absolute,
      })
        .then(res => ({
          current: res,
          existing,
        }))
    )
    
    // Compare the two
    .then(res => {
      const missingFiles = res.existing.data.filter(ex =>
        res.current.filter(cu => cu.file === ex.file).length === 0
      );
      const newFiles = res.current.filter(cu =>
        res.existing.data.filter(ex => ex.file === cu.file).length === 0
      );
      const diffHashes = res.current.filter(cu => {
        const ex = res.existing.data.filter(ex => ex.file === cu.file);
        return ex.length > 0 ?
          ex[0].hash !== cu.hash :
          false;
      });
      return {
        missing:  missingFiles,
        new:      newFiles,
        diffHash: diffHashes,
      };
    })

    // Output results
    .then(res => {
      logger.log(3, '\nResults: -');
      logger.log(3, `  Files in snapshot missing from current: ${res.missing.length}`);
      logger.log(3, `  Files in current which are not in snapshot: ${res.new.length}`);
      logger.log(3, `  Files with content that does not match snapshot: ${res.diffHash.length}`);

      if (res.missing.length > 0)
      {
        logger.log(3, '\nFiles in snapshot missing from current: -');
        logger.log(3, res.missing.map(x => ` - ${x.file}`).join('\n'));
      }

      if (res.new.length > 0)
      {
        logger.log(3, '\nFiles in current which are not in snapshot: -');
        logger.log(3, res.new.map(x => ` - ${x.file}`).join('\n'));
      }

      if (res.diffHash.length > 0)
      {
        logger.log(3, '\nFiles with content that does not match snapshot: -');
        logger.log(3, res.diffHash.map(x => ` - ${x.file}`).join('\n'));
      }
    })

    .then(() => logger.log(3, '\nScript finished'))

    .catch(err => {
      logger.log(1, err.toString());
    });
}
