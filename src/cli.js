/* eslint no-console: ["error", {"allow": ["log", "warn", "error"]}] */

import {executeTests, formatResult} from './web_exploit_detector';

import Promise  from 'bluebird';
import minimist from 'minimist';

const fs = Promise.promisifyAll(require('graceful-fs'));

const argv = minimist(
  process.argv.slice(2),
  {
    boolean: true,
    default: {
      'debug': false,
      'exclude-tags': undefined,
      'help': false,
      'include-deprecated': false,
      'parallel': true,
      'tags': undefined,
      'verbose': false,
      'webroot': undefined,
    },
  }
);

function printUsage() {
  logger(3, `Usage: node ${process.argv[1]} --webroot=<web_root>`);
  logger(3, '  --debug: sets the debug flag: enables the "debug" rules.');
  logger(3, '  --exclude-tags=<list>: excludes all rules that include one or more of the comma-separated tags in <list>.');
  logger(3, '  --help: shows this message');
  logger(3, '  --include-deprecated: includes rulesmarked as deprecated.');
  logger(3, '  --no-parallel: disables parallel processing if set. While parallel processing is technically faster, it has a higher resource usage when running.');
  logger(3, '  --output=<file>: writes all rules with matched file paths (if any) in JSON format to <file>.');
  logger(3, '  --tags=<list>: only runs rules matching the comma-separated <list> of tags.');
  logger(3, '  --verbose: enables verbose log output.');
  logger(3, '  --webroot=<web_root>: sets the base directory that will be searched recursively to <web_root>.');
  logger(3, '\n\nExamples: ');
  logger(3, '  - Search the /var/www/html directory structure: -');
  logger(3, `    node ${process.argv[1]} --webroot=/var/www/html\n`);
  logger(3, '  - Search for actual exploits only, not suspicious files: -');
  logger(3, `    node ${process.argv[1]} --webroot=/var/www/html --exclude-tags=suspicion\n`);
  logger(3, '  - Search using only WordPress-related rules: -');
  logger(3, `    node ${process.argv[1]} --webroot=/var/www/html --tags=wordpress\n`);
  logger(3, '  - Search using all rules except those tagged with "jquery" or "js": -');
  logger(3, `    node ${process.argv[1]} --webroot=/var/www/html --exclude-tags=jquery,js\n`);
}

function logger(level, msg) {
  switch (level) {
    case 1:
      console.error(msg);
      break;
    case 2:
      console.warn(msg);
      break;
    case 3:
      console.log(msg);
      break;
    default:
      if (argv.verbose)
        console.log(msg);
  }
}


export default function execute() {
  logger(3, 'Web Exploit Detector by Simon Pugnet ((c) 2017)\n');

  if (argv.help)
  {
    printUsage();
    process.exit(0);
  }

  if (!argv.webroot)
  {
    logger(1, 'ERROR: --webroot command line argument must be specified\n');
    printUsage();
    process.exit(1);
  }

  executeTests({
    debug:              argv.debug,
    exclude_tags:       argv['exclude-tags'],
    include_deprecated: argv['include-deprecated'],
    parallel:           argv.parallel,
    tags:               argv.tags,
    verbose:            argv.verbose,
    webroot:            argv.webroot,

    logger,
  })

    // Output results JSON to file if required
    .then(res => {
      if (argv.output && typeof argv.output !== 'boolean' && argv.output.toString().length > 0)
      {
        const resultsWithMatches = res.filter(x => x.matches.length > 0);
        if (resultsWithMatches.length === 0)
        {
          logger(4, 'No matches found, so nothing to output to file');
          return res;
        }
        logger(4, `Outputting results to ${argv.output}...`);
        return fs.writeFileAsync(
          argv.output,
          JSON.stringify(
            resultsWithMatches.map(x => ({
              rule: {
                id:          x.rule.id,
                name:        x.rule.name,
                description: x.rule.description,
                tags:        x.rule.tags,
                deprecated:  x.rule.deprecated,
                urls:        x.rule.urls,
              },
              matches: x.matches,
            })),
            null,
            '\t'
          )
        )
          .then(() => {
            return res;
          })
          .catch(err => {
            logger(1, `ERROR: unable to write results to file: ${err.toString()}`);
            return res;
          });
      }
      return res;
    })

    // Write results to console
    .then(res =>
      logger(3, 
        'Processing complete, results: -\n\n' +
        res
          .map(formatResult)
          .filter(x => x !== null)
          .join('\n')
      )
    );
}
