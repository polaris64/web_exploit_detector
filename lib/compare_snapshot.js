'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = execute;

var _web_exploit_detector = require('./web_exploit_detector');

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _minimist = require('minimist');

var _minimist2 = _interopRequireDefault(_minimist);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fs = _bluebird2.default.promisifyAll(require('graceful-fs'));

var argv = (0, _minimist2.default)(process.argv.slice(2), {
  boolean: true,
  default: {
    'help': false,
    'snapshot': undefined,
    'verbose': false,
    'webroot': undefined
  }
});

var logger = new _logger2.default(argv);

function printUsage() {
  logger.log(3, 'Usage: node ' + process.argv[1] + ' --snapshot=<snapshot_file>');
  logger.log(3, '  --help: shows this message');
  logger.log(3, '  --snapshot=<snapshot_file>: a previously generated snapshot file.');
  logger.log(3, '  --verbose: enables verbose log output.');
  logger.log(3, '  --webroot=<web_root>: sets the base directory that will be scanned recursively to <web_root>. This is stored in the snapshot itself, so this option should only be set if the value in the snapshot needs to be overridden.');
}

function execute() {
  logger.log(3, 'Directory tree snapshot checking utility ((c) Simon Pugnet 2017)\n');
  logger.log(4, 'This tool compares all files and their contents in a directory with a previously generated snapshot of that same directory, specified by --snapshot. Any differences between the two will be displayed.');

  if (argv.help) {
    printUsage();
    process.exit(0);
  }

  if (!(argv.snapshot && typeof argv.snapshot !== 'boolean' && argv.snapshot.toString().length > 0)) {
    logger.log(1, 'ERROR: --snapshot command line argument must be specified\n');
    printUsage();
    process.exit(1);
  }

  // Read the existing snapshot
  return fs.readFileAsync(argv.snapshot)

  // Parse and validate the existing snapshot
  .then(function (existingSnap) {
    var existing = JSON.parse(existingSnap.toString());

    // Make sure snapshot contains data
    if (!existing.data) existing = {
      meta: {},
      data: existing
    };

    // Make sure snapshot contains a meta.webroot attribute. If it does not
    // then set it based on --webroot (if possible)
    if (!(existing.meta && existing.meta.webroot)) {
      if (!argv.webroot) return _bluebird2.default.reject(new Error('This snapshot does not contain a webroot so the --webroot command line argument must be specified when using this snapshot file'));

      if (!existing.meta) existing.meta = {};
      existing.meta.webroot = argv.webroot;

      // If the existing snapshot did not include a webroot then all paths
      // will be absolute so set a flag to prevent the snapshot generator
      // from generating relative paths
      existing.meta.absolute = true;
    }

    // If --webroot was specified, override value stored in snapshot
    else if (argv.webroot && typeof argv.webroot !== 'boolean' && argv.webroot.toString().length > 0) {
        logger.log(2, 'WARNING: snapshot contains a webroot value of ' + existing.meta.webroot + ' however the --webroot option was specified, so overriding this value to ' + argv.webroot + '...');
        existing.meta.webroot = argv.webroot;
      }

    if (existing.meta.timestamp) logger.log(3, 'Comparing snapshot generated for path ' + existing.meta.webroot + ' at ' + new Date(existing.meta.timestamp).toString());

    return existing;
  })

  // Generate a new snapshot
  .then(function (existing) {
    return (0, _web_exploit_detector.getTreeSnapshot)({
      output: argv.output,
      verbose: argv.verbose,
      webroot: existing.meta.webroot,

      logger: logger.log,
      relative: !existing.meta.absolute
    }).then(function (res) {
      return {
        current: res,
        existing: existing
      };
    });
  })

  // Compare the two
  .then(function (res) {
    var missingFiles = res.existing.data.filter(function (ex) {
      return res.current.filter(function (cu) {
        return cu.file === ex.file;
      }).length === 0;
    });
    var newFiles = res.current.filter(function (cu) {
      return res.existing.data.filter(function (ex) {
        return ex.file === cu.file;
      }).length === 0;
    });
    var diffHashes = res.current.filter(function (cu) {
      var ex = res.existing.data.filter(function (ex) {
        return ex.file === cu.file;
      });
      return ex.length > 0 ? ex[0].hash !== cu.hash : false;
    });
    return {
      missing: missingFiles,
      new: newFiles,
      diffHash: diffHashes
    };
  })

  // Output results
  .then(function (res) {
    logger.log(3, '\nResults: -');
    logger.log(3, '  Files in snapshot missing from current: ' + res.missing.length);
    logger.log(3, '  Files in current which are not in snapshot: ' + res.new.length);
    logger.log(3, '  Files with content that does not match snapshot: ' + res.diffHash.length);

    if (res.missing.length > 0) {
      logger.log(3, '\nFiles in snapshot missing from current: -');
      logger.log(3, res.missing.map(function (x) {
        return ' - ' + x.file;
      }).join('\n'));
    }

    if (res.new.length > 0) {
      logger.log(3, '\nFiles in current which are not in snapshot: -');
      logger.log(3, res.new.map(function (x) {
        return ' - ' + x.file;
      }).join('\n'));
    }

    if (res.diffHash.length > 0) {
      logger.log(3, '\nFiles with content that does not match snapshot: -');
      logger.log(3, res.diffHash.map(function (x) {
        return ' - ' + x.file;
      }).join('\n'));
    }
  }).then(function () {
    return logger.log(3, '\nScript finished');
  }).catch(function (err) {
    logger.log(1, err.toString());
  });
}