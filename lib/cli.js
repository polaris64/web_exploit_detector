'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = execute;

var _web_exploit_detector = require('./web_exploit_detector');

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _minimist = require('minimist');

var _minimist2 = _interopRequireDefault(_minimist);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fs = _bluebird2.default.promisifyAll(require('graceful-fs')); /* eslint no-console: ["error", {"allow": ["log", "warn", "error"]}] */

var argv = (0, _minimist2.default)(process.argv.slice(2), {
  boolean: true,
  default: {
    'debug': false,
    'exclude-tags': undefined,
    'help': false,
    'include-deprecated': false,
    'parallel': true,
    'tags': undefined,
    'verbose': false,
    'webroot': undefined
  }
});

function printUsage() {
  logger(3, 'Usage: node ' + process.argv[1] + ' --webroot=<web_root>');
  logger(3, '  --debug: sets the debug flag: enables the "debug" rules.');
  logger(3, '  --exclude-tags=<list>: excludes all rules that include one or more of the comma-separated tags in <list>.');
  logger(3, '  --help: shows this message');
  logger(3, '  --include-deprecated: includes rulesmarked as deprecated.');
  logger(3, '  --no-parallel: disables parallel processing if set. While parallel processing is technically faster, it has a higher resource usage when running.');
  logger(3, '  --output=<file>: writes all rules with matched file paths (if any) in JSON format to <file>.');
  logger(3, '  --tags=<list>: only runs rules matching the comma-separated <list> of tags.');
  logger(3, '  --verbose: enables verbose log output.');
  logger(3, '  --webroot=<web_root>: sets the base directory that will be searched recursively to <web_root>.');
  logger(3, '\n\nExamples: ');
  logger(3, '  - Search the /var/www/html directory structure: -');
  logger(3, '    node ' + process.argv[1] + ' --webroot=/var/www/html\n');
  logger(3, '  - Search for actual exploits only, not suspicious files: -');
  logger(3, '    node ' + process.argv[1] + ' --webroot=/var/www/html --exclude-tags=suspicion\n');
  logger(3, '  - Search using only WordPress-related rules: -');
  logger(3, '    node ' + process.argv[1] + ' --webroot=/var/www/html --tags=wordpress\n');
  logger(3, '  - Search using all rules except those tagged with "jquery" or "js": -');
  logger(3, '    node ' + process.argv[1] + ' --webroot=/var/www/html --exclude-tags=jquery,js\n');
}

function logger(level, msg) {
  switch (level) {
    case 1:
      console.error(msg);
      break;
    case 2:
      console.warn(msg);
      break;
    case 3:
      console.log(msg);
      break;
    default:
      if (argv.verbose) console.log(msg);
  }
}

function execute() {
  logger(3, 'Web Exploit Detector by Simon Pugnet ((c) 2017)\n');

  if (argv.help) {
    printUsage();
    process.exit(0);
  }

  if (!argv.webroot) {
    logger(1, 'ERROR: --webroot command line argument must be specified\n');
    printUsage();
    process.exit(1);
  }

  (0, _web_exploit_detector.executeTests)({
    debug: argv.debug,
    exclude_tags: argv['exclude-tags'],
    include_deprecated: argv['include-deprecated'],
    parallel: argv.parallel,
    tags: argv.tags,
    verbose: argv.verbose,
    webroot: argv.webroot,

    logger: logger
  })

  // Output results JSON to file if required
  .then(function (res) {
    if (argv.output && typeof argv.output !== 'boolean' && argv.output.toString().length > 0) {
      var resultsWithMatches = res.filter(function (x) {
        return x.matches.length > 0;
      });
      if (resultsWithMatches.length === 0) {
        logger(4, 'No matches found, so nothing to output to file');
        return res;
      }
      logger(4, 'Outputting results to ' + argv.output + '...');
      return fs.writeFileAsync(argv.output, JSON.stringify(resultsWithMatches.map(function (x) {
        return {
          rule: {
            id: x.rule.id,
            name: x.rule.name,
            description: x.rule.description,
            tags: x.rule.tags,
            deprecated: x.rule.deprecated,
            urls: x.rule.urls
          },
          matches: x.matches
        };
      }), null, '\t')).then(function () {
        return res;
      }).catch(function (err) {
        logger(1, 'ERROR: unable to write results to file: ' + err.toString());
        return res;
      });
    }
    return res;
  })

  // Write results to console
  .then(function (res) {
    return logger(3, 'Processing complete, results: -\n\n' + res.map(_web_exploit_detector.formatResult).filter(function (x) {
      return x !== null;
    }).join('\n'));
  });
}